"use strict";(self.webpackChunkwebb_monorepo=self.webpackChunkwebb_monorepo||[]).push([[5408],{"./node_modules/@noble/hashes/esm/_assert.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function bytes(b,...lengths){if(!function isBytes(a){return a instanceof Uint8Array||null!=a&&"object"==typeof a&&"Uint8Array"===a.constructor.name}(b))throw new Error("Uint8Array expected");if(lengths.length>0&&!lengths.includes(b.length))throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`)}function hash(h){if("function"!=typeof h||"function"!=typeof h.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");number(h.outputLen),number(h.blockLen)}function exists(instance,checkFinished=!0){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function output(out,instance){bytes(out);const min=instance.outputLen;if(out.length<min)throw new Error(`digestInto() expects output buffer of length at least ${min}`)}__webpack_require__.d(__webpack_exports__,{CG:()=>output,ai:()=>number,ee:()=>bytes,t2:()=>exists,tW:()=>hash})},"./node_modules/@noble/hashes/esm/_u64.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Ay:()=>__WEBPACK_DEFAULT_EXPORT__,B4:()=>rotlSL,P5:()=>rotlSH,WM:()=>rotlBH,im:()=>rotlBL,lD:()=>split});const U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(n,le=!1){return le?{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)}:{h:0|Number(n>>_32n&U32_MASK64),l:0|Number(n&U32_MASK64)}}function split(lst,le=!1){let Ah=new Uint32Array(lst.length),Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const rotlSH=(h,l,s)=>h<<s|l>>>32-s,rotlSL=(h,l,s)=>l<<s|h>>>32-s,rotlBH=(h,l,s)=>l<<s-32|h>>>64-s,rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;const __WEBPACK_DEFAULT_EXPORT__={fromBig,split,toBig:(h,l)=>BigInt(h>>>0)<<_32n|BigInt(l>>>0),shrSH:(h,_l,s)=>h>>>s,shrSL:(h,l,s)=>h<<32-s|l>>>s,rotrSH:(h,l,s)=>h>>>s|l<<32-s,rotrSL:(h,l,s)=>h<<32-s|l>>>s,rotrBH:(h,l,s)=>h<<64-s|l>>>s-32,rotrBL:(h,l,s)=>h>>>s-32|l<<64-s,rotr32H:(_h,l)=>l,rotr32L:(h,_l)=>h,rotlSH,rotlSL,rotlBH,rotlBL,add:function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:0|l}},add3L:(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0),add3H:(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0,add4L:(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0),add4H:(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0,add5H:(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0,add5L:(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0)}},"./node_modules/@noble/hashes/esm/sha256.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{s:()=>sha256});var _assert=__webpack_require__("./node_modules/@noble/hashes/esm/_assert.js"),utils=__webpack_require__("./node_modules/@noble/hashes/esm/utils.js");const Maj=(a,b,c)=>a&b^a&c^b&c;class HashMD extends utils.Vw{constructor(blockLen,outputLen,padOffset,isLE){super(),this.blockLen=blockLen,this.outputLen=outputLen,this.padOffset=padOffset,this.isLE=isLE,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(blockLen),this.view=(0,utils.O8)(this.buffer)}update(data){(0,_assert.t2)(this);const{view,buffer,blockLen}=this,len=(data=(0,utils.ZJ)(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take!==blockLen)buffer.set(data.subarray(pos,pos+take),this.pos),this.pos+=take,pos+=take,this.pos===blockLen&&(this.process(view,0),this.pos=0);else{const dataView=(0,utils.O8)(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos)}}return this.length+=data.length,this.roundClean(),this}digestInto(out){(0,_assert.t2)(this),(0,_assert.CG)(out,this),this.finished=!0;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128,this.buffer.subarray(pos).fill(0),this.padOffset>blockLen-pos&&(this.process(view,0),pos=0);for(let i=pos;i<blockLen;i++)buffer[i]=0;!function setBigUint64(view,byteOffset,value,isLE){if("function"==typeof view.setBigUint64)return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32),_u32_max=BigInt(4294967295),wh=Number(value>>_32n&_u32_max),wl=Number(value&_u32_max),h=isLE?4:0,l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE),view.setUint32(byteOffset+l,wl,isLE)}(view,blockLen-8,BigInt(8*this.length),isLE),this.process(view,0);const oview=(0,utils.O8)(out),len=this.outputLen;if(len%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const outLen=len/4,state=this.get();if(outLen>state.length)throw new Error("_sha2: outputLen bigger than state");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);return this.destroy(),res}_cloneInto(to){to||(to=new this.constructor),to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;return to.length=length,to.pos=pos,to.finished=finished,to.destroyed=destroyed,length%blockLen&&to.buffer.set(buffer),to}}const SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends HashMD{constructor(){super(64,32,8,!1),this.A=0|SHA256_IV[0],this.B=0|SHA256_IV[1],this.C=0|SHA256_IV[2],this.D=0|SHA256_IV[3],this.E=0|SHA256_IV[4],this.F=0|SHA256_IV[5],this.G=0|SHA256_IV[6],this.H=0|SHA256_IV[7]}get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=0|A,this.B=0|B,this.C=0|C,this.D=0|D,this.E=0|E,this.F=0|F,this.G=0|G,this.H=0|H}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,!1);for(let i=16;i<64;i++){const W15=SHA256_W[i-15],W2=SHA256_W[i-2],s0=(0,utils.Ow)(W15,7)^(0,utils.Ow)(W15,18)^W15>>>3,s1=(0,utils.Ow)(W2,17)^(0,utils.Ow)(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const T1=H+((0,utils.Ow)(E,6)^(0,utils.Ow)(E,11)^(0,utils.Ow)(E,25))+((a=E)&F^~a&G)+SHA256_K[i]+SHA256_W[i]|0,T2=((0,utils.Ow)(A,2)^(0,utils.Ow)(A,13)^(0,utils.Ow)(A,22))+Maj(A,B,C)|0;H=G,G=F,F=E,E=D+T1|0,D=C,C=B,B=A,A=T1+T2|0}var a;A=A+this.A|0,B=B+this.B|0,C=C+this.C|0,D=D+this.D|0,E=E+this.E|0,F=F+this.F|0,G=G+this.G|0,H=H+this.H|0,this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const sha256=(0,utils.ld)((()=>new SHA256))},"./node_modules/@noble/hashes/esm/sha3.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{a0:()=>keccak_512,lY:()=>keccak_256});var _assert_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@noble/hashes/esm/_assert.js"),_u64_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@noble/hashes/esm/_u64.js"),_utils_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@noble/hashes/esm/utils.js");const SHA3_PI=[],SHA3_ROTL=[],_SHA3_IOTA=[],_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_7n=BigInt(7),_256n=BigInt(256),_0x71n=BigInt(113);for(let round=0,R=_1n,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5],SHA3_PI.push(2*(5*y+x)),SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n;for(let j=0;j<7;j++)R=(R<<_1n^(R>>_7n)*_0x71n)%_256n,R&_2n&&(t^=_1n<<(_1n<<BigInt(j))-_1n);_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=(0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.lD)(_SHA3_IOTA,!0),rotlH=(h,l,s)=>s>32?(0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.WM)(h,l,s):(0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.P5)(h,l,s),rotlL=(h,l,s)=>s>32?(0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.im)(h,l,s):(0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.B4)(h,l,s);class Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Vw{constructor(blockLen,suffix,outputLen,enableXOF=!1,rounds=24){if(super(),this.blockLen=blockLen,this.suffix=suffix,this.outputLen=outputLen,this.enableXOF=enableXOF,this.rounds=rounds,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.ai)(outputLen),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.DH)(this.state)}keccak(){_utils_js__WEBPACK_IMPORTED_MODULE_1__.qv||(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.Fc)(this.state32),function keccakP(s,rounds=24){const B=new Uint32Array(10);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10,idx0=(x+2)%10,B0=B[idx0],B1=B[idx0+1],Th=rotlH(B0,B1,1)^B[idx1],Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10)s[x+y]^=Th,s[x+y+1]^=Tl}let curH=s[2],curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t],Th=rotlH(curH,curL,shift),Tl=rotlL(curH,curL,shift),PI=SHA3_PI[t];curH=s[PI],curL=s[PI+1],s[PI]=Th,s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round],s[1]^=SHA3_IOTA_L[round]}B.fill(0)}(this.state32,this.rounds),_utils_js__WEBPACK_IMPORTED_MODULE_1__.qv||(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.Fc)(this.state32),this.posOut=0,this.pos=0}update(data){(0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.t2)(this);const{blockLen,state}=this,len=(data=(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ZJ)(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];this.pos===blockLen&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix,128&suffix&&pos===blockLen-1&&this.keccak(),state[blockLen-1]^=128,this.keccak()}writeInto(out){(0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.t2)(this,!1),(0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.ee)(out),this.finish();const bufferOut=this.state,{blockLen}=this;for(let pos=0,len=out.length;pos<len;){this.posOut>=blockLen&&this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos),this.posOut+=take,pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(out)}xof(bytes){return(0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.ai)(bytes),this.xofInto(new Uint8Array(bytes))}digestInto(out){if((0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.CG)(out,this),this.finished)throw new Error("digest() was already called");return this.writeInto(out),this.destroy(),out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;return to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds)),to.state32.set(this.state32),to.pos=this.pos,to.posOut=this.posOut,to.finished=this.finished,to.rounds=rounds,to.suffix=suffix,to.outputLen=outputLen,to.enableXOF=enableXOF,to.destroyed=this.destroyed,to}}const gen=(suffix,blockLen,outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ld)((()=>new Keccak(blockLen,suffix,outputLen))),keccak_256=gen(1,136,32),keccak_512=gen(1,72,64)},"./node_modules/@noble/hashes/esm/utils.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Vw:()=>Hash,Fc:()=>byteSwap32,c:()=>byteSwapIfBE,Id:()=>concatBytes,O8:()=>createView,qv:()=>isLE,po:()=>randomBytes,Ow:()=>rotr,ZJ:()=>toBytes,DH:()=>u32,ld:()=>wrapConstructor,t6:()=>wrapConstructorWithOpts});const crypto_crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;var _assert=__webpack_require__("./node_modules/@noble/hashes/esm/_assert.js");const u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4)),createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength),rotr=(word,shift)=>word<<32-shift|word>>>shift,isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],byteSwap=word=>word<<24&4278190080|word<<8&16711680|word>>>8&65280|word>>>24&255,byteSwapIfBE=isLE?n=>n:n=>byteSwap(n);function byteSwap32(arr){for(let i=0;i<arr.length;i++)arr[i]=byteSwap(arr[i])}function toBytes(data){return"string"==typeof data&&(data=function utf8ToBytes(str){if("string"!=typeof str)throw new Error("utf8ToBytes expected string, got "+typeof str);return new Uint8Array((new TextEncoder).encode(str))}(data)),(0,_assert.ee)(data),data}function concatBytes(...arrays){let sum=0;for(let i=0;i<arrays.length;i++){const a=arrays[i];(0,_assert.ee)(a),sum+=a.length}const res=new Uint8Array(sum);for(let i=0,pad=0;i<arrays.length;i++){const a=arrays[i];res.set(a,pad),pad+=a.length}return res}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC}function wrapConstructorWithOpts(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC}function randomBytes(bytesLength=32){if(crypto_crypto&&"function"==typeof crypto_crypto.getRandomValues)return crypto_crypto.getRandomValues(new Uint8Array(bytesLength));throw new Error("crypto.getRandomValues must be defined")}}}]);