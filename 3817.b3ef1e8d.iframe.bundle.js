"use strict";(self.webpackChunkwebb_monorepo=self.webpackChunkwebb_monorepo||[]).push([[3817],{"./node_modules/@noble/hashes/esm/_assert.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function bytes(b,...lengths){if(!function isBytes(a){return a instanceof Uint8Array||null!=a&&"object"==typeof a&&"Uint8Array"===a.constructor.name}(b))throw new Error("Uint8Array expected");if(lengths.length>0&&!lengths.includes(b.length))throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`)}function hash(h){if("function"!=typeof h||"function"!=typeof h.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");number(h.outputLen),number(h.blockLen)}function exists(instance,checkFinished=!0){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function output(out,instance){bytes(out);const min=instance.outputLen;if(out.length<min)throw new Error(`digestInto() expects output buffer of length at least ${min}`)}__webpack_require__.d(__webpack_exports__,{CG:()=>output,ai:()=>number,ee:()=>bytes,t2:()=>exists,tW:()=>hash})},"./node_modules/@noble/hashes/esm/_u64.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Ay:()=>__WEBPACK_DEFAULT_EXPORT__,B4:()=>rotlSL,P5:()=>rotlSH,WM:()=>rotlBH,im:()=>rotlBL,lD:()=>split});const U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(n,le=!1){return le?{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)}:{h:0|Number(n>>_32n&U32_MASK64),l:0|Number(n&U32_MASK64)}}function split(lst,le=!1){let Ah=new Uint32Array(lst.length),Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const rotlSH=(h,l,s)=>h<<s|l>>>32-s,rotlSL=(h,l,s)=>l<<s|h>>>32-s,rotlBH=(h,l,s)=>l<<s-32|h>>>64-s,rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;const __WEBPACK_DEFAULT_EXPORT__={fromBig,split,toBig:(h,l)=>BigInt(h>>>0)<<_32n|BigInt(l>>>0),shrSH:(h,_l,s)=>h>>>s,shrSL:(h,l,s)=>h<<32-s|l>>>s,rotrSH:(h,l,s)=>h>>>s|l<<32-s,rotrSL:(h,l,s)=>h<<32-s|l>>>s,rotrBH:(h,l,s)=>h<<64-s|l>>>s-32,rotrBL:(h,l,s)=>h>>>s-32|l<<64-s,rotr32H:(_h,l)=>l,rotr32L:(h,_l)=>h,rotlSH,rotlSL,rotlBH,rotlBL,add:function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:0|l}},add3L:(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0),add3H:(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0,add4L:(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0),add4H:(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0,add5H:(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0,add5L:(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0)}},"./node_modules/@noble/hashes/esm/utils.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Vw:()=>Hash,Fc:()=>byteSwap32,c:()=>byteSwapIfBE,Id:()=>concatBytes,O8:()=>createView,qv:()=>isLE,po:()=>randomBytes,Ow:()=>rotr,ZJ:()=>toBytes,DH:()=>u32,ld:()=>wrapConstructor,t6:()=>wrapConstructorWithOpts});const crypto_crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;var _assert=__webpack_require__("./node_modules/@noble/hashes/esm/_assert.js");const u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4)),createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength),rotr=(word,shift)=>word<<32-shift|word>>>shift,isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],byteSwap=word=>word<<24&4278190080|word<<8&16711680|word>>>8&65280|word>>>24&255,byteSwapIfBE=isLE?n=>n:n=>byteSwap(n);function byteSwap32(arr){for(let i=0;i<arr.length;i++)arr[i]=byteSwap(arr[i])}function toBytes(data){return"string"==typeof data&&(data=function utf8ToBytes(str){if("string"!=typeof str)throw new Error("utf8ToBytes expected string, got "+typeof str);return new Uint8Array((new TextEncoder).encode(str))}(data)),(0,_assert.ee)(data),data}function concatBytes(...arrays){let sum=0;for(let i=0;i<arrays.length;i++){const a=arrays[i];(0,_assert.ee)(a),sum+=a.length}const res=new Uint8Array(sum);for(let i=0,pad=0;i<arrays.length;i++){const a=arrays[i];res.set(a,pad),pad+=a.length}return res}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC}function wrapConstructorWithOpts(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC}function randomBytes(bytesLength=32){if(crypto_crypto&&"function"==typeof crypto_crypto.getRandomValues)return crypto_crypto.getRandomValues(new Uint8Array(bytesLength));throw new Error("crypto.getRandomValues must be defined")}},"./node_modules/@polkadot/extension-dapp/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{isWeb3Injected:()=>isWeb3Injected,packageInfo:()=>packageInfo,unwrapBytes:()=>unwrapBytes,web3Accounts:()=>web3Accounts,web3AccountsSubscribe:()=>web3AccountsSubscribe,web3Enable:()=>web3Enable,web3EnablePromise:()=>web3EnablePromise,web3FromAddress:()=>web3FromAddress,web3FromSource:()=>web3FromSource,web3ListRpcProviders:()=>web3ListRpcProviders,web3UseRpcProvider:()=>web3UseRpcProvider,wrapBytes:()=>wrapBytes});const isPromise=(0,__webpack_require__("./node_modules/@polkadot/util/is/helpers.js").D8)("catch","then");var toU8a=__webpack_require__("./node_modules/@polkadot/util/u8a/toU8a.js");function u8aEq(a,b){const u8aa=(0,toU8a.e)(a),u8ab=(0,toU8a.e)(b);if(u8aa.length===u8ab.length){const dvA=new DataView(u8aa.buffer,u8aa.byteOffset),dvB=new DataView(u8ab.buffer,u8ab.byteOffset),mod=u8aa.length%4|0,length=u8aa.length-mod|0;for(let i=0;i<length;i+=4)if(dvA.getUint32(i)!==dvB.getUint32(i))return!1;for(let i=length,count=u8aa.length;i<count;i++)if(u8aa[i]!==u8ab[i])return!1;return!0}return!1}var encode=__webpack_require__("./node_modules/@polkadot/util-crypto/address/encode.js"),decode=__webpack_require__("./node_modules/@polkadot/util-crypto/address/decode.js");const packageInfo={name:"@polkadot/extension-dapp",path:new URL("file:///home/runner/work/webb-dapp/webb-dapp/node_modules/@polkadot/extension-dapp/packageInfo.js").pathname.substring(0,new URL("file:///home/runner/work/webb-dapp/webb-dapp/node_modules/@polkadot/extension-dapp/packageInfo.js").pathname.lastIndexOf("/")+1),type:"esm",version:"0.47.5"};var concat=__webpack_require__("./node_modules/@polkadot/util/u8a/concat.js");const wrap_U8A_WRAP_ETHEREUM=(0,toU8a.e)("Ethereum Signed Message:\n"),wrap_U8A_WRAP_PREFIX=(0,toU8a.e)("<Bytes>"),wrap_U8A_WRAP_POSTFIX=(0,toU8a.e)("</Bytes>"),WRAP_LEN=wrap_U8A_WRAP_PREFIX.length+wrap_U8A_WRAP_POSTFIX.length;function wrap_u8aIsWrapped(u8a,withEthereum){return u8a.length>=WRAP_LEN&&u8aEq(u8a.subarray(0,wrap_U8A_WRAP_PREFIX.length),wrap_U8A_WRAP_PREFIX)&&u8aEq(u8a.slice(-wrap_U8A_WRAP_POSTFIX.length),wrap_U8A_WRAP_POSTFIX)||withEthereum&&u8a.length>=wrap_U8A_WRAP_ETHEREUM.length&&u8aEq(u8a.subarray(0,wrap_U8A_WRAP_ETHEREUM.length),wrap_U8A_WRAP_ETHEREUM)}const unwrapBytes=function u8aUnwrapBytes(bytes){const u8a=(0,toU8a.e)(bytes);return wrap_u8aIsWrapped(u8a,!1)?u8a.subarray(wrap_U8A_WRAP_PREFIX.length,u8a.length-wrap_U8A_WRAP_POSTFIX.length):u8a},wrapBytes=function u8aWrapBytes(bytes){const u8a=(0,toU8a.e)(bytes);return wrap_u8aIsWrapped(u8a,!0)?u8a:(0,concat.Q)([wrap_U8A_WRAP_PREFIX,u8a,wrap_U8A_WRAP_POSTFIX])};var console=__webpack_require__("./node_modules/console-browserify/index.js");const win=window;win.injectedWeb3=win.injectedWeb3||{};let isWeb3Injected=web3IsInjected(),web3EnablePromise=null;function web3IsInjected(){return 0!==Object.values(win.injectedWeb3).filter((({connect,enable})=>!(!connect&&!enable))).length}function throwError(method){throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`)}function mapAccounts(source,list,ss58Format){return list.map((({address,genesisHash,name,type})=>({address:42===address.length?address:(0,encode.j)((0,decode.F)(address),ss58Format),meta:{genesisHash,name,source},type})))}function filterAccounts(list,genesisHash,type){return list.filter((a=>(!a.type||!type||type.includes(a.type))&&(!a.genesisHash||!genesisHash||a.genesisHash===genesisHash)))}function getWindowExtensions(originName){return Promise.all(Object.entries(win.injectedWeb3).map((([nameOrHash,{connect,enable,version}])=>Promise.resolve().then((()=>connect?connect(originName):enable?enable(originName).then((e=>function objectSpread(dest,...sources){for(let i=0,count=sources.length;i<count;i++){const src=sources[i];if(src)if("function"==typeof src.entries)for(const[key,value]of src.entries())dest[key]=value;else Object.assign(dest,src)}return dest}({name:nameOrHash,version:version||"unknown"},e))):Promise.reject(new Error("No connect(..) or enable(...) hook found")))).catch((({message})=>{console.error(`Error initializing ${nameOrHash}: ${message}`)}))))).then((exts=>exts.filter((e=>!!e))))}async function filterEnable(caller,extensions){if(!web3EnablePromise)return throwError(caller);return(await web3EnablePromise).filter((({name})=>!extensions||extensions.includes(name)))}function web3Enable(originName,compatInits=[]){if(!originName)throw new Error("You must pass a name for your app to the web3Enable function");const initCompat=compatInits.length?Promise.all(compatInits.map((c=>c().catch((()=>!1))))):Promise.resolve([!0]);return web3EnablePromise=function documentReadyPromise(creator){return new Promise((resolve=>{"complete"===document.readyState?resolve(creator()):window.addEventListener("load",(()=>resolve(creator())))}))}((()=>initCompat.then((()=>getWindowExtensions(originName).then((values=>values.map((e=>(e.accounts.subscribe||(e.accounts.subscribe=cb=>(e.accounts.get().then(cb).catch(console.error),()=>{})),e))))).catch((()=>[])).then((values=>{const names=values.map((({name,version})=>`${name}/${version}`));return isWeb3Injected=web3IsInjected(),console.info(`web3Enable: Enabled ${values.length} extension${1!==values.length?"s":""}: ${names.join(", ")}`),values})))))),web3EnablePromise}async function web3Accounts({accountType,extensions,genesisHash,ss58Format}={}){const accounts=[],sources=await filterEnable("web3Accounts",extensions),retrieved=await Promise.all(sources.map((async({accounts,name:source})=>{try{return mapAccounts(source,filterAccounts(await accounts.get(),genesisHash,accountType),ss58Format)}catch{return[]}})));return retrieved.forEach((result=>{accounts.push(...result)})),console.info(`web3Accounts: Found ${accounts.length} address${1!==accounts.length?"es":""}`),accounts}async function web3AccountsSubscribe(cb,{accountType,extensions,genesisHash,ss58Format}={}){const sources=await filterEnable("web3AccountsSubscribe",extensions),accounts={},unsubs=sources.map((({accounts:{subscribe},name:source})=>subscribe((result=>{accounts[source]=result;try{const result=cb(Object.entries(accounts).reduce(((result,[source,list])=>(result.push(...mapAccounts(source,filterAccounts(list,genesisHash,accountType),ss58Format)),result)),[]));result&&isPromise(result)&&result.catch(console.error)}catch(error){console.error(error)}}))));return()=>{unsubs.forEach((unsub=>{unsub()}))}}async function web3FromSource(source){if(!web3EnablePromise)return throwError("web3FromSource");const sources=await web3EnablePromise,found=source&&sources.find((({name})=>name===source));if(!found)throw new Error(`web3FromSource: Unable to find an injected ${source}`);return found}async function web3FromAddress(address){if(!web3EnablePromise)return throwError("web3FromAddress");const accounts=await web3Accounts();let found;if(address){const accountU8a=(0,decode.F)(address);found=accounts.find((account=>u8aEq((0,decode.F)(account.address),accountU8a)))}if(!found)throw new Error(`web3FromAddress: Unable to find injected ${address}`);return web3FromSource(found.meta.source)}async function web3ListRpcProviders(source){const{provider}=await web3FromSource(source);return provider?provider.listProviders():(console.warn(`Extension ${source} does not expose any provider`),null)}async function web3UseRpcProvider(source,key){const{provider}=await web3FromSource(source);if(!provider)throw new Error(`Extension ${source} does not expose any provider`);return{meta:await provider.startProvider(key),provider}}},"./node_modules/@polkadot/util-crypto/address/encode.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{j:()=>encodeAddress});var _polkadot_util__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@polkadot/util/u8a/concat.js"),_base58_index_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@polkadot/util-crypto/base58/bs58.js"),_decode_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@polkadot/util-crypto/address/decode.js"),_defaults_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@polkadot/util-crypto/address/defaults.js"),_sshash_js__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@polkadot/util-crypto/address/sshash.js");function encodeAddress(key,ss58Format=_defaults_js__WEBPACK_IMPORTED_MODULE_0__.N.prefix){const u8a=(0,_decode_js__WEBPACK_IMPORTED_MODULE_1__.F)(key);if(ss58Format<0||ss58Format>16383||[46,47].includes(ss58Format))throw new Error("Out of range ss58Format specified");if(!_defaults_js__WEBPACK_IMPORTED_MODULE_0__.N.allowedDecodedLengths.includes(u8a.length))throw new Error(`Expected a valid key to convert, with length ${_defaults_js__WEBPACK_IMPORTED_MODULE_0__.N.allowedDecodedLengths.join(", ")}`);const input=(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_2__.z)(ss58Format<64?[ss58Format]:[(252&ss58Format)>>2|64,ss58Format>>8|(3&ss58Format)<<6],u8a);return(0,_base58_index_js__WEBPACK_IMPORTED_MODULE_3__.Rl)((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_2__.z)(input,(0,_sshash_js__WEBPACK_IMPORTED_MODULE_4__.f)(input).subarray(0,[32,33].includes(u8a.length)?2:1)))}},"./node_modules/@polkadot/util/is/helpers.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Mp:()=>isOn,D8:()=>isOnObject});var is_function=__webpack_require__("./node_modules/@polkadot/util/is/function.js");function isObject(value){return!!value&&"object"==typeof value}function isOn(...fns){return value=>(isObject(value)||(0,is_function.T)(value))&&fns.every((f=>(0,is_function.T)(value[f])))}function isOnObject(...fns){return value=>isObject(value)&&fns.every((f=>(0,is_function.T)(value[f])))}}}]);