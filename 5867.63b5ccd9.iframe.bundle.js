"use strict";(self.webpackChunkwebb_monorepo=self.webpackChunkwebb_monorepo||[]).push([[5867],{"./node_modules/@noble/hashes/esm/_assert.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function bytes(b,...lengths){if(!function isBytes(a){return a instanceof Uint8Array||null!=a&&"object"==typeof a&&"Uint8Array"===a.constructor.name}(b))throw new Error("Uint8Array expected");if(lengths.length>0&&!lengths.includes(b.length))throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`)}function hash(h){if("function"!=typeof h||"function"!=typeof h.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");number(h.outputLen),number(h.blockLen)}function exists(instance,checkFinished=!0){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function output(out,instance){bytes(out);const min=instance.outputLen;if(out.length<min)throw new Error(`digestInto() expects output buffer of length at least ${min}`)}__webpack_require__.d(__webpack_exports__,{CG:()=>output,ai:()=>number,ee:()=>bytes,t2:()=>exists,tW:()=>hash})},"./node_modules/@noble/hashes/esm/_u64.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Ay:()=>__WEBPACK_DEFAULT_EXPORT__,B4:()=>rotlSL,P5:()=>rotlSH,WM:()=>rotlBH,im:()=>rotlBL,lD:()=>split});const U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(n,le=!1){return le?{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)}:{h:0|Number(n>>_32n&U32_MASK64),l:0|Number(n&U32_MASK64)}}function split(lst,le=!1){let Ah=new Uint32Array(lst.length),Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const rotlSH=(h,l,s)=>h<<s|l>>>32-s,rotlSL=(h,l,s)=>l<<s|h>>>32-s,rotlBH=(h,l,s)=>l<<s-32|h>>>64-s,rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;const __WEBPACK_DEFAULT_EXPORT__={fromBig,split,toBig:(h,l)=>BigInt(h>>>0)<<_32n|BigInt(l>>>0),shrSH:(h,_l,s)=>h>>>s,shrSL:(h,l,s)=>h<<32-s|l>>>s,rotrSH:(h,l,s)=>h>>>s|l<<32-s,rotrSL:(h,l,s)=>h<<32-s|l>>>s,rotrBH:(h,l,s)=>h<<64-s|l>>>s-32,rotrBL:(h,l,s)=>h>>>s-32|l<<64-s,rotr32H:(_h,l)=>l,rotr32L:(h,_l)=>h,rotlSH,rotlSL,rotlBH,rotlBL,add:function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:0|l}},add3L:(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0),add3H:(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0,add4L:(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0),add4H:(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0,add5H:(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0,add5L:(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0)}},"./node_modules/@noble/hashes/esm/sha3.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{a0:()=>keccak_512,lY:()=>keccak_256});var _assert_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@noble/hashes/esm/_assert.js"),_u64_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@noble/hashes/esm/_u64.js"),_utils_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@noble/hashes/esm/utils.js");const SHA3_PI=[],SHA3_ROTL=[],_SHA3_IOTA=[],_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_7n=BigInt(7),_256n=BigInt(256),_0x71n=BigInt(113);for(let round=0,R=_1n,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5],SHA3_PI.push(2*(5*y+x)),SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n;for(let j=0;j<7;j++)R=(R<<_1n^(R>>_7n)*_0x71n)%_256n,R&_2n&&(t^=_1n<<(_1n<<BigInt(j))-_1n);_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=(0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.lD)(_SHA3_IOTA,!0),rotlH=(h,l,s)=>s>32?(0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.WM)(h,l,s):(0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.P5)(h,l,s),rotlL=(h,l,s)=>s>32?(0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.im)(h,l,s):(0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.B4)(h,l,s);class Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Vw{constructor(blockLen,suffix,outputLen,enableXOF=!1,rounds=24){if(super(),this.blockLen=blockLen,this.suffix=suffix,this.outputLen=outputLen,this.enableXOF=enableXOF,this.rounds=rounds,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.ai)(outputLen),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.DH)(this.state)}keccak(){_utils_js__WEBPACK_IMPORTED_MODULE_1__.qv||(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.Fc)(this.state32),function keccakP(s,rounds=24){const B=new Uint32Array(10);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10,idx0=(x+2)%10,B0=B[idx0],B1=B[idx0+1],Th=rotlH(B0,B1,1)^B[idx1],Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10)s[x+y]^=Th,s[x+y+1]^=Tl}let curH=s[2],curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t],Th=rotlH(curH,curL,shift),Tl=rotlL(curH,curL,shift),PI=SHA3_PI[t];curH=s[PI],curL=s[PI+1],s[PI]=Th,s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round],s[1]^=SHA3_IOTA_L[round]}B.fill(0)}(this.state32,this.rounds),_utils_js__WEBPACK_IMPORTED_MODULE_1__.qv||(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.Fc)(this.state32),this.posOut=0,this.pos=0}update(data){(0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.t2)(this);const{blockLen,state}=this,len=(data=(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ZJ)(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];this.pos===blockLen&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix,128&suffix&&pos===blockLen-1&&this.keccak(),state[blockLen-1]^=128,this.keccak()}writeInto(out){(0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.t2)(this,!1),(0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.ee)(out),this.finish();const bufferOut=this.state,{blockLen}=this;for(let pos=0,len=out.length;pos<len;){this.posOut>=blockLen&&this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos),this.posOut+=take,pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(out)}xof(bytes){return(0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.ai)(bytes),this.xofInto(new Uint8Array(bytes))}digestInto(out){if((0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.CG)(out,this),this.finished)throw new Error("digest() was already called");return this.writeInto(out),this.destroy(),out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;return to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds)),to.state32.set(this.state32),to.pos=this.pos,to.posOut=this.posOut,to.finished=this.finished,to.rounds=rounds,to.suffix=suffix,to.outputLen=outputLen,to.enableXOF=enableXOF,to.destroyed=this.destroyed,to}}const gen=(suffix,blockLen,outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ld)((()=>new Keccak(blockLen,suffix,outputLen))),keccak_256=gen(1,136,32),keccak_512=gen(1,72,64)},"./node_modules/@noble/hashes/esm/utils.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Vw:()=>Hash,Fc:()=>byteSwap32,c:()=>byteSwapIfBE,Id:()=>concatBytes,O8:()=>createView,qv:()=>isLE,po:()=>randomBytes,Ow:()=>rotr,ZJ:()=>toBytes,DH:()=>u32,ld:()=>wrapConstructor,t6:()=>wrapConstructorWithOpts});const crypto_crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;var _assert=__webpack_require__("./node_modules/@noble/hashes/esm/_assert.js");const u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4)),createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength),rotr=(word,shift)=>word<<32-shift|word>>>shift,isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],byteSwap=word=>word<<24&4278190080|word<<8&16711680|word>>>8&65280|word>>>24&255,byteSwapIfBE=isLE?n=>n:n=>byteSwap(n);function byteSwap32(arr){for(let i=0;i<arr.length;i++)arr[i]=byteSwap(arr[i])}function toBytes(data){return"string"==typeof data&&(data=function utf8ToBytes(str){if("string"!=typeof str)throw new Error("utf8ToBytes expected string, got "+typeof str);return new Uint8Array((new TextEncoder).encode(str))}(data)),(0,_assert.ee)(data),data}function concatBytes(...arrays){let sum=0;for(let i=0;i<arrays.length;i++){const a=arrays[i];(0,_assert.ee)(a),sum+=a.length}const res=new Uint8Array(sum);for(let i=0,pad=0;i<arrays.length;i++){const a=arrays[i];res.set(a,pad),pad+=a.length}return res}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC}function wrapConstructorWithOpts(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC}function randomBytes(bytesLength=32){if(crypto_crypto&&"function"==typeof crypto_crypto.getRandomValues)return crypto_crypto.getRandomValues(new Uint8Array(bytesLength));throw new Error("crypto.getRandomValues must be defined")}},"./node_modules/@polkadot/util-crypto/address/is.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{P:()=>isAddress});var decode=__webpack_require__("./node_modules/@polkadot/util-crypto/address/decode.js");function isAddress(address,ignoreChecksum,ss58Format){try{return function validateAddress(encoded,ignoreChecksum,ss58Format){return!!(0,decode.F)(encoded,ignoreChecksum,ss58Format)}(address,ignoreChecksum,ss58Format)}catch{return!1}}},"./node_modules/@polkadot/util-crypto/ethereum/isAddress.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{q:()=>isEthereumAddress});var hex=__webpack_require__("./node_modules/@polkadot/util/is/hex.js"),toHex=__webpack_require__("./node_modules/@polkadot/util/u8a/toHex.js"),asU8a=__webpack_require__("./node_modules/@polkadot/util-crypto/keccak/asU8a.js");function isEthereumAddress(address){return!(!address||42!==address.length||!(0,hex.qv)(address))&&(!(!/^(0x)?[0-9a-f]{40}$/.test(address)&&!/^(0x)?[0-9A-F]{40}$/.test(address))||function isEthereumChecksum(_address){const address=_address.replace("0x",""),hash=(0,toHex.X)((0,asU8a.H1)(address.toLowerCase()),-1,!1);for(let i=0;i<40;i++)if(char=address[i],byte=parseInt(hash[i],16),char!==(byte>7?char.toUpperCase():char.toLowerCase()))return!1;var char,byte;return!0}(address))}},"./node_modules/@polkadot/util-crypto/keccak/asU8a.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{H1:()=>keccakAsU8a});var sha3=__webpack_require__("./node_modules/@noble/hashes/esm/sha3.js"),bundle=__webpack_require__("./node_modules/@polkadot/wasm-crypto/bundle.js"),toU8a=__webpack_require__("./node_modules/@polkadot/util/u8a/toU8a.js"),has=__webpack_require__("./node_modules/@polkadot/util/has.js");function createDualHasher(wa,js){return(value,bitLength=256,onlyJs)=>{const u8a=(0,toU8a.e)(value);return!has.CW||!onlyJs&&(0,bundle.i_)()?wa[bitLength](u8a):js[bitLength](u8a)}}const keccakAsU8a=createDualHasher({256:bundle.So,512:bundle.Rc},{256:sha3.lY,512:sha3.a0})},"./node_modules/@polkadot/util/u8a/toHex.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{X:()=>u8aToHex});const U8=new Array(256),U16=new Array(65536);for(let n=0;n<256;n++)U8[n]=n.toString(16).padStart(2,"0");for(let i=0;i<256;i++){const s=i<<8;for(let j=0;j<256;j++)U16[s|j]=U8[i]+U8[j]}function hex(value,result){const mod=value.length%2|0,length=value.length-mod|0;for(let i=0;i<length;i+=2)result+=U16[value[i]<<8|value[i+1]];return mod&&(result+=U8[0|value[length]]),result}function u8aToHex(value,bitLength=-1,isPrefixed=!0){const empty=isPrefixed?"0x":"";if(!value?.length)return empty;if(bitLength>0){const length=Math.ceil(bitLength/8);if(value.length>length)return`${hex(value.subarray(0,length/2),empty)}â€¦${hex(value.subarray(value.length-length/2),"")}`}return hex(value,empty)}}}]);