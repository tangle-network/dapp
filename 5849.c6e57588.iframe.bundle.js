"use strict";(self.webpackChunkwebb_monorepo=self.webpackChunkwebb_monorepo||[]).push([[5849],{"./node_modules/@polkadot/extension-dapp/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{isWeb3Injected:()=>isWeb3Injected,packageInfo:()=>packageInfo,unwrapBytes:()=>unwrapBytes,web3Accounts:()=>web3Accounts,web3AccountsSubscribe:()=>web3AccountsSubscribe,web3Enable:()=>web3Enable,web3EnablePromise:()=>web3EnablePromise,web3FromAddress:()=>web3FromAddress,web3FromSource:()=>web3FromSource,web3ListRpcProviders:()=>web3ListRpcProviders,web3UseRpcProvider:()=>web3UseRpcProvider,wrapBytes:()=>wrapBytes});const isPromise=(0,__webpack_require__("./node_modules/@polkadot/util/is/helpers.js").be)("catch","then");var toU8a=__webpack_require__("./node_modules/@polkadot/util/u8a/toU8a.js");function u8aEq(a,b){const u8aa=(0,toU8a.Y)(a),u8ab=(0,toU8a.Y)(b);if(u8aa.length===u8ab.length){const dvA=new DataView(u8aa.buffer,u8aa.byteOffset),dvB=new DataView(u8ab.buffer,u8ab.byteOffset),mod=u8aa.length%4|0,length=u8aa.length-mod|0;for(let i=0;i<length;i+=4)if(dvA.getUint32(i)!==dvB.getUint32(i))return!1;for(let i=length,count=u8aa.length;i<count;i++)if(u8aa[i]!==u8ab[i])return!1;return!0}return!1}var encode=__webpack_require__("./node_modules/@polkadot/util-crypto/address/encode.js"),decode=__webpack_require__("./node_modules/@polkadot/util-crypto/address/decode.js");const packageInfo={name:"@polkadot/extension-dapp",path:new URL("file:///home/runner/work/webb-dapp/webb-dapp/node_modules/@polkadot/extension-dapp/packageInfo.js").pathname.substring(0,new URL("file:///home/runner/work/webb-dapp/webb-dapp/node_modules/@polkadot/extension-dapp/packageInfo.js").pathname.lastIndexOf("/")+1),type:"esm",version:"0.46.6"};var concat=__webpack_require__("./node_modules/@polkadot/util/u8a/concat.js");const wrap_U8A_WRAP_ETHEREUM=(0,toU8a.Y)("Ethereum Signed Message:\n"),wrap_U8A_WRAP_PREFIX=(0,toU8a.Y)("<Bytes>"),wrap_U8A_WRAP_POSTFIX=(0,toU8a.Y)("</Bytes>"),WRAP_LEN=wrap_U8A_WRAP_PREFIX.length+wrap_U8A_WRAP_POSTFIX.length;function wrap_u8aIsWrapped(u8a,withEthereum){return u8a.length>=WRAP_LEN&&u8aEq(u8a.subarray(0,wrap_U8A_WRAP_PREFIX.length),wrap_U8A_WRAP_PREFIX)&&u8aEq(u8a.slice(-wrap_U8A_WRAP_POSTFIX.length),wrap_U8A_WRAP_POSTFIX)||withEthereum&&u8a.length>=wrap_U8A_WRAP_ETHEREUM.length&&u8aEq(u8a.subarray(0,wrap_U8A_WRAP_ETHEREUM.length),wrap_U8A_WRAP_ETHEREUM)}const unwrapBytes=function u8aUnwrapBytes(bytes){const u8a=(0,toU8a.Y)(bytes);return wrap_u8aIsWrapped(u8a,!1)?u8a.subarray(wrap_U8A_WRAP_PREFIX.length,u8a.length-wrap_U8A_WRAP_POSTFIX.length):u8a},wrapBytes=function u8aWrapBytes(bytes){const u8a=(0,toU8a.Y)(bytes);return wrap_u8aIsWrapped(u8a,!0)?u8a:(0,concat.d)([wrap_U8A_WRAP_PREFIX,u8a,wrap_U8A_WRAP_POSTFIX])},win=window;win.injectedWeb3=win.injectedWeb3||{};let isWeb3Injected=web3IsInjected(),web3EnablePromise=null;function web3IsInjected(){return 0!==Object.values(win.injectedWeb3).filter((({connect,enable})=>!(!connect&&!enable))).length}function throwError(method){throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`)}function mapAccounts(source,list,ss58Format){return list.map((({address,genesisHash,name,type})=>({address:42===address.length?address:(0,encode.m)((0,decode.m)(address),ss58Format),meta:{genesisHash,name,source},type})))}function filterAccounts(list,genesisHash,type){return list.filter((a=>(!a.type||!type||type.includes(a.type))&&(!a.genesisHash||!genesisHash||a.genesisHash===genesisHash)))}function getWindowExtensions(originName){return Promise.all(Object.entries(win.injectedWeb3).map((([nameOrHash,{connect,enable,version}])=>Promise.resolve().then((()=>connect?connect(originName):enable?enable(originName).then((e=>function objectSpread(dest,...sources){for(let i=0,count=sources.length;i<count;i++){const src=sources[i];if(src)if("function"==typeof src.entries)for(const[key,value]of src.entries())dest[key]=value;else Object.assign(dest,src)}return dest}({name:nameOrHash,version:version||"unknown"},e))):Promise.reject(new Error("No connect(..) or enable(...) hook found")))).catch((({message})=>{console.error(`Error initializing ${nameOrHash}: ${message}`)}))))).then((exts=>exts.filter((e=>!!e))))}async function filterEnable(caller,extensions){if(!web3EnablePromise)return throwError(caller);return(await web3EnablePromise).filter((({name})=>!extensions||extensions.includes(name)))}function web3Enable(originName,compatInits=[]){if(!originName)throw new Error("You must pass a name for your app to the web3Enable function");const initCompat=compatInits.length?Promise.all(compatInits.map((c=>c().catch((()=>!1))))):Promise.resolve([!0]);return web3EnablePromise=function documentReadyPromise(creator){return new Promise((resolve=>{"complete"===document.readyState?resolve(creator()):window.addEventListener("load",(()=>resolve(creator())))}))}((()=>initCompat.then((()=>getWindowExtensions(originName).then((values=>values.map((e=>(e.accounts.subscribe||(e.accounts.subscribe=cb=>(e.accounts.get().then(cb).catch(console.error),()=>{})),e))))).catch((()=>[])).then((values=>{const names=values.map((({name,version})=>`${name}/${version}`));return isWeb3Injected=web3IsInjected(),console.info(`web3Enable: Enabled ${values.length} extension${1!==values.length?"s":""}: ${names.join(", ")}`),values})))))),web3EnablePromise}async function web3Accounts({accountType,extensions,genesisHash,ss58Format}={}){const accounts=[],sources=await filterEnable("web3Accounts",extensions),retrieved=await Promise.all(sources.map((async({accounts,name:source})=>{try{return mapAccounts(source,filterAccounts(await accounts.get(),genesisHash,accountType),ss58Format)}catch{return[]}})));return retrieved.forEach((result=>{accounts.push(...result)})),console.info(`web3Accounts: Found ${accounts.length} address${1!==accounts.length?"es":""}`),accounts}async function web3AccountsSubscribe(cb,{accountType,extensions,genesisHash,ss58Format}={}){const sources=await filterEnable("web3AccountsSubscribe",extensions),accounts={},unsubs=sources.map((({accounts:{subscribe},name:source})=>subscribe((result=>{accounts[source]=result;try{const result=cb(Object.entries(accounts).reduce(((result,[source,list])=>(result.push(...mapAccounts(source,filterAccounts(list,genesisHash,accountType),ss58Format)),result)),[]));result&&isPromise(result)&&result.catch(console.error)}catch(error){console.error(error)}}))));return()=>{unsubs.forEach((unsub=>{unsub()}))}}async function web3FromSource(source){if(!web3EnablePromise)return throwError("web3FromSource");const sources=await web3EnablePromise,found=source&&sources.find((({name})=>name===source));if(!found)throw new Error(`web3FromSource: Unable to find an injected ${source}`);return found}async function web3FromAddress(address){if(!web3EnablePromise)return throwError("web3FromAddress");const accounts=await web3Accounts();let found;if(address){const accountU8a=(0,decode.m)(address);found=accounts.find((account=>u8aEq((0,decode.m)(account.address),accountU8a)))}if(!found)throw new Error(`web3FromAddress: Unable to find injected ${address}`);return web3FromSource(found.meta.source)}async function web3ListRpcProviders(source){const{provider}=await web3FromSource(source);return provider?provider.listProviders():(console.warn(`Extension ${source} does not expose any provider`),null)}async function web3UseRpcProvider(source,key){const{provider}=await web3FromSource(source);if(!provider)throw new Error(`Extension ${source} does not expose any provider`);return{meta:await provider.startProvider(key),provider}}},"./node_modules/@polkadot/util-crypto/address/encode.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{m:()=>encodeAddress});var _polkadot_util__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@polkadot/util/u8a/concat.js"),_base58_index_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@polkadot/util-crypto/base58/bs58.js"),_decode_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@polkadot/util-crypto/address/decode.js"),_defaults_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@polkadot/util-crypto/address/defaults.js"),_sshash_js__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@polkadot/util-crypto/address/sshash.js");function encodeAddress(key,ss58Format=_defaults_js__WEBPACK_IMPORTED_MODULE_0__.c.prefix){const u8a=(0,_decode_js__WEBPACK_IMPORTED_MODULE_1__.m)(key);if(ss58Format<0||ss58Format>16383||[46,47].includes(ss58Format))throw new Error("Out of range ss58Format specified");if(!_defaults_js__WEBPACK_IMPORTED_MODULE_0__.c.allowedDecodedLengths.includes(u8a.length))throw new Error(`Expected a valid key to convert, with length ${_defaults_js__WEBPACK_IMPORTED_MODULE_0__.c.allowedDecodedLengths.join(", ")}`);const input=(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_2__.e)(ss58Format<64?[ss58Format]:[(252&ss58Format)>>2|64,ss58Format>>8|(3&ss58Format)<<6],u8a);return(0,_base58_index_js__WEBPACK_IMPORTED_MODULE_3__.ni)((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_2__.e)(input,(0,_sshash_js__WEBPACK_IMPORTED_MODULE_4__.b)(input).subarray(0,[32,33].includes(u8a.length)?2:1)))}},"./node_modules/@polkadot/util/is/helpers.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{F7:()=>isOn,be:()=>isOnObject});var is_function=__webpack_require__("./node_modules/@polkadot/util/is/function.js");function isObject(value){return!!value&&"object"==typeof value}function isOn(...fns){return value=>(isObject(value)||(0,is_function.m)(value))&&fns.every((f=>(0,is_function.m)(value[f])))}function isOnObject(...fns){return value=>isObject(value)&&fns.every((f=>(0,is_function.m)(value[f])))}}}]);